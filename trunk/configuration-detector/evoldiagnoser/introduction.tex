\section{Introduction}
\label{sec:introduction}

Many modern software systems are configurable. They
have a large number of configuration options for users
to customize their behavior. This flexibility has a cost:
a small configuration error might lead to hard-to-diagnose
behaviors.
%when something goes wrong, diagnosing a configuration
%error can be both time-consuming and furstrating.

Software configuration errors are errors in which
the application code and the input are correct, but the software is
misconfigured so that it does not behave
as desired by the end-user. Such errors may lead software to crash,
produce erroneous output, or simply perform poorly.
In practice, software configuration
errors are \textit{prevalent}, \textit{severe}, and
\textit{hard to debug}, but they are \textit{actionable} for users to fix.


%In many modern software systems, configuration errors have been
%the dominant cause of problems~\cite{}.
A recent analysis of Yahoo's mission-critical Zookeeper service
showed that software misconfigurations accounted for
the majority of all user-visible failures~\cite{bft}. Another
recent study analyzed reported problems of a commercial
storage company, and found configuration-related issues
caused about 31\% of all failures~\cite{Yin:2011:ESC}.
Further, as described in a recent article about system deployment experience
in Google, the vast majority of production failures (in Google)
arise not due to bugs in the software, but bugs in the
configuration settings (i.e., configuration errors)
that control the software~\cite{googleconf}.

Not only are configuration errors prevalent, they
can have high, sometimes disastrous impacts. For example,
an outage in Facebook due to
an incorrect configuration value left the website 
inaccessible for about 2 hours~\cite{fbout}. 
The entire \CodeIn{.se} domain of Sweden was unavailable
for about 1 hour, due to a DNS misconfiguration problem~\cite{sedown}.
On July 26 2012, 
a misconfiguration made 
Microsoft's public cloud platform, Azure,
unavailable for about two and a half hours~\cite{msdown}.
Such incidents affected millions of users.

Furthermore, configuration errors are difficult to diagnose. 
They usually require great expertise to understand
the error root causes. For example, in one
configuration error of CentOS described in~\cite{Yin:2011:ESC},
the user could not mount a newly created file system,
because the CentOS kernel for this file system was
misconfigured. The user need to have deep understanding about the
exhibited symptom,  and re-install kernel modules and
also modify configuration option values in
several places to get it to work.
Techniques helping escape from the ``configuration hell''
are highly demanded~\cite{googleconf}.

Unlike software bugs,
which can only be fixed by experienced software developers, fixing a software
configuration error is \textit{actionable} for software end-users
or system administrators. These users are not the software developers,
and do not have the right expertise to understand (or even access to)
the source code;  but they can fix a configuration error by simply changing
values of certain configuration options.


\subsection{Configuration Evolution}
\label{sec:evolerror}

Continual change is a fact of life for software systems.
Among software changes, configuration changes are prevalent.
In an initial study of \studysubjnum real-world configurable software
systems (Section~\ref{sec:study}),
we found that configuration changes happen in \textit{every} studied
version of \textit{each} system. In many 
cases, directly reusing the existing configuration
for the old version for the new
version can lead the software to exhibit \textit{undesired} behaviors,
even if the software is working exactly as \textit{designed}.


%After upgrading to a new version,
%users often need to carefully exam the existing configuration, and may
%configure the software properly. \todo{xx}
%Otherwise, the software is working exactly as designed, but the
%wrong configuration is leading it to exhibit the undesired behavior.
%\todo{not the right place}
%Inappropriate reconfiguration can lead to serious results.

%Configuration errors are different from software regression bugs.
%They can still happen even after an unrealistically comprehensive
%regression test suite (with 100\% coverage ) passes. This is primarily
%because 

% \todo{I propose that we cut this paragraph.  It doesn't seem to be
%   contributing much.}
% Differing from software regression bugs, configuration errors are mostly user driven.
% They occur when the use of software is unexpected
% situations, in which it does not behave as a user would expect.
% For software developers,
% it is impossible for them to test software in every possible
% situation in which it might be misconfigured; in fact, it is usually
% impossible even to foresee every such situation. 


Take the popular JMeter performance testing tool as an example.
In version 2.8, the testing report is saved as an XML
file after running an example command (\CodeIn{jmeter -n -t ../threadgroup.jmx -l ../output.jtl -j ../test.log})
%\footnote{\CodeIn{jmeter -n -t ../threadgroup.jmx -l ../output.jtl -j ../test.log}}
from the user manual.
However, after upgrading to version 2.9, 
the same command saves the testing report
in a CSV file. Further, all JMeter regression tests pass 
on the updated version.  The new JMeter version
just behaves as \textit{designed} but \textit{differently}
than a user was expecting.


%To understand why a configuration error happens and
%troubleshoot it to obtain the desired behavior,
%users often need to seek information
%from online help forums, software manuals, or
%ask experts. This process can be tedious, laborious, and frustrating.

Our technique (and its tool implementation \ourtool) can help
diagnose configuration errors. For the JMeter example,
users first demonstrate the different
behaviors on two \ourtool-instrumented
JMeter versions. Then, \ourtool analyzes the
recorded execution traces produced by the two instrumented
versions, and outputs a ranked list of root cause configuration options.
At the top of the list is the
\CodeIn{output\_format} option with a default value of \CodeIn{CSV}
in version 2.9.
To resolve this problem, users only need to change
its value to \CodeIn{XML}.

\subsection{Configuration Option Recommendation}

Broadly speaking, diagnosing a configuration
error can be divided into three separate tasks:
reproducing the error, recommending which specific
configuration option is responsible for the undesired
behavior, and determining a better value for the
configuration option to fix the error. \ourtool addresses
the second task: recommending the root cause configuration options.
%a configuration error.

\ourtool specifically focuses on software configuration errors, and
aims to help two types of users: software end-users
who may have problems with software installed on their
personal computers, and system administrators who are
responsible for maintaining production systems.
They can use \ourtool to diagnose an unexpected configuration
problem during software evolution. 
%to troubleshoot an
%error they encounter but do not know how to fix it. 

%when they counter
%an error that they do not know how to fix, to troubleshoot a
%configuration error 
%\ourtool's output can help such users resolve the problems
%they encounter.

%\ourtool focuses on diagnosing configuration errors
%caused by software evolution. 
The key idea of \ourtool is to approximate program behavioral
differences by control flow differences between 
two executions (by running the old
and new program versions, respectively),
and then reason about the control flow differences to
identify configuration options that
might cause such differences. It uses
three steps, as illustrated in Figure~\ref{fig:overview},  to link the undesired
behavior to specific root cause configuration options:

\vspace{-2mm}

\begin{itemize}

\item \textbf{Instrumentation and Profiling.} \ourtool
instruments both old and new program versions by inserting
code to monitor the execution of each statement as well as the
evaluation result of every predicate. Then, it asks users to
demonstrate the different behaviors on the two instrumented
program versions. 
%User demonstration produces two execution
%traces resulting from the desired and undesired program
%behaviors, respectively.

\item \textbf{Execution Trace Comparison.}
\ourtool analyzes the two execution traces to identify
the control flow differences. In particular, \ourtool
identifies program predicates that behave
differently between two versions. These
behaviorally-deviated predicates and their
affected program statements
provide evidence about what parts of a program might
be behaving abnormally and why.

\item \textbf{Configuration Option Recommendation.} 
\ourtool uses a lightweight static dependence analysis
technique, called thin slicing~\cite{Sridharan:2007}, to attribute
control flow differences to specific configuration options.
Finally, it outputs a ranked list of suspicious options to the users.


\end{itemize}

Compared to existing error diagnosis
techniques~\cite{Wang:2004:AMT, Rabkin:2011:PPC, Whitaker:2004:CDS,
Zhang:2013:ADS, Attariyan:2010:ACT, Su:2007:AIC, Attariyan:2008:UCD, xray
}, \ourtool differs in four
key aspects:

\begin{itemize}
\item \textbf{It diagnoses configuration errors caused by software evolution}.
Most existing configuration error diagnosis techniques
try to identify errors from a single program
version~\cite{Wang:2004:AMT, Rabkin:2011:PPC, Whitaker:2004:CDS,
Zhang:2013:ADS, Attariyan:2010:ACT, Su:2007:AIC, Attariyan:2008:UCD, xray}.
By contrast, \ourtool is cognizant of software evolution and
works on two different versions of the same program. 
It uses the desired behavior on the old software version
as a baseline with which to compare new program behavior against, and only
reasons about the behavioral differences.

\item \textbf{It requires no testing oracle}.
Some previous work~\cite{Rabkin:2011:PPC, Whitaker:2004:CDS,
Attariyan:2010:ACT, Su:2007:AIC} requires the user to answer difficult
questions like ``is the software currently working?''\ or ``why is the
software not working?''\ by writing a testing
oracle to check the software behavior. By contrast,
\ourtool only requires users to
demonstrate the different behaviors on two versions.
\ourtool uses the execution trace produced in the old
version as an approximate oracle to
reason about the undesired behavior in the new version.

\item \textbf{It determines likely root cause options}.
Many error diagnosis and debugging techniques~\cite{dd, autoflow}
primarily focus on
determining \textit{what} causes the undesired behaviors, e.g.,
a snippet of code --- they leave the more challenging
question of \textit{how} to fix the undesired behaviors
unanswered.  Users must manually inspect the analysis
report to infer
the root cause, e.g., a configuration option,
of the unexpected behaviors 
based on their expertise and knowledge of the software.
By contrast, \ourtool makes reports in terms that 
end users understand and can act on:  it explicitly guides users to specific
configuration options that may fix the error.

\item \textbf{It requires no OS-level support}. \ourtool
does not need alterations to the JVM, operating system, or
standard library. This makes \ourtool more portable, and
distinguishes it from related techniques, such as
OS-level configuration error diagnosis~\cite{Whitaker:2004:CDS, Su:2007:AIC}.

\end{itemize}

\subsection{Evaluation}

We implemented \ourtool for Java software and empirically evaluated
its effectiveness using \errornum configuration errors
from \subjnum open-source configurable Java software systems. 
We used \ourtool to recommend configuration options whose values
can be changed to fix each error.
\ourtool successfully recommended correct configuration options
for all \errornum errors. In 6 errors, the correct option was \ourtool's first
suggestion. In 1 error, the correct option was
\ourtool's third suggestion. The root cause of the remaining
error was \ourtool's sixth suggestion. \ourtool is fast enough for practical use,
taking less than \avgtime minutes to diagnose one configuration error, on average.
\ourtool's accuracy and speed make it a promising technique.


We compared \ourtool to two existing configuration error diagnosis
techniques, called \prevtool~\cite{Zhang:2013:ADS}
and \conftool~\cite{Rabkin:2011:PPC}.
\prevtool assumes the existence of some correct execution traces
on the new program version; by contrast, \ourtool eliminates the
assumption.
\conftool exclusively focuses on diagnosing crashing configuration errors;
by contrast, \ourtool can diagnose both crashing errors and
non-crashing errors.
%Both \prevtool and \conftool can identify a configuration option, but they
%do not suggest a new value; by contrast, \ourtool makes a specific
%suggestion.
Our experiments
show that \ourtool significantly outperforms these two existing techniques.

Finally, we evaluated two internal design choices of \ourtool. First, we 
showed that using thin slicing~\cite{Sridharan:2007} is a better choice than
the traditional full slicing~\cite{Horwitz:1988} to reason about the
root cause configuration options. Second, we showed that 
\ourtool outperforms an alternative approach
that only uses predicate behavior change to reason about
the root cause configuration options.



%Overall, we find that \ourtool is highly effective at helping
%identify the root cause of cross-version behavioral differences. 

\subsection{Contributions}

This paper makes the following main contributions:

\begin{itemize}
\vspace{-3mm}
\item \textbf{Study.} We describe an empirical
study of 9 configurable software systems.
Our study indicates that configuration changes
are frequent and persistent during software evolution (Section~\ref{sec:study}).

\item \textbf{Technique.} We present a technique to diagnose
configuration errors for evolving software. Our technique
uses dynamic profiling, execution trace comparison, and
static analysis to link certain undesired behaviors to a
specific responsible configuration option (Section~\ref{sec:technique}).

\item \textbf{Implementation.} We implemented our technique
in a tool, called \ourtool, for Java software (Section~\ref{sec:implementation}).
It is publicly available as open source at \url{http://config-errors.googlecode.com}.

\item \textbf{Evaluation.} We applied \ourtool to \errornum configuration
errors from \subjnum configurable software systems,
and compared it with existing techniques.
The results show the accuracy and efficiency of \ourtool (Section~\ref{sec:evaluation}).
\end{itemize}

%  LocalWords:  Zookeeper misconfigurations se DNS JMeter jmeter CSV
