\ourtool first instruments both the old and new program versions
to monitor the program  execution at runtime. \ourtool directly
instruments the bytecode. The instrumentation
consists of two parts:

\vspace{-2mm}

\begin{itemize}
\item For each program predicate (i.e., a branch instruction
in bytecode), \ourtool inserts one
probe before and one probe after it
to monitor how frequently the predicate is executed and
how often the predicate evaluates to true. In our
context, a predicate is a Boolean expression in a
conditional or loop statement,
whose evaluation result affects the program
control flow by determining whether to execute the
following statement or not.


\item For each of the other statements, \ourtool inserts
one probe before it to monitor whether the statement
gets executed or not at runtime. The statement execution
information is used to calculate the number of executed
statements controlled by a predicate (Section~\ref{sec:rootcause}).

%\todo{This seems excessively inefficient.  The probe should only be
%  necessary at the start of each basic block, unless you are concerned
%  about exceptions.}

%\todo{Where is this information about non-predicate statements used?  I see
%  that the algorithm uses the true ratio for predicates, but not where it
%  uses the number of executions for arbitrary statements.  Oh, maybe it's
%  used in getExecutedStmtNum, but that isn't clear.}

\end{itemize}


\vspace{-1mm}

After instrumentation, \ourtool asks the user to demonstrate the different
behaviors on the two instrumented program versions, by using
the same input and configuration. Demonstration is
one of the simplest ways for an end-user to describe her problem;
and it is easier than writing specifications or scripts of any form.

Executing the instrumented program produces an execution trace,
which consists of a sequence of executed statements as well
as the evaluation result of each predicate.
The execution trace captured by \ourtool is by no means complete
in recording the full program behavior; it only
captures the control flows a program is taking. As demonstrated
in our experiments, such control flow information serves as a
good approximation to diagnose the undesired program behavior.

%determine which parts of the program behave
%abnormally.
% are
%responsible for the behavioral difference and why.


%predicates and their
%evaluation results. Such captured predicate behaviors are by
%no means complete in recording the full execution trace. However,
%they capture control flows a program is taking. Thus, using the
%recorded predicate execution result, \ourtool could faithfully
%derive the full execution path. 


%  LocalWords:  getExecutedStmtNum
