
\begin{figure}[t]
\textbf{Auxiliary methods:}

\quad getAffectingOptions($\mathit{p}$, $\mathit{V}$): return all
configuration options that may affect predicate $\mathit{p}$ in the software version $\mathit{V}$
\todo{Is this thin slicing?  If so, say so to clarify.}

\quad getExecutedStmtNum($\mathit{p}$, $\mathit{V}$, $\mathit{T}$): return the number of executed statements (determined by predicate $\mathit{p}$) in trace $\mathit{T}$
\todo{I'm not sure what this means.  By ``determined'', do you mean ``controlled''?}

\textbf{Input}: two software version: $\mathit{V_{old}}$ and $\mathit{V_{new}}$, 

\quad the map of all behaviorally-deviated predicates: $\mathit{predMap}$, produced by Figure~\ref{fig:identify}.

\textbf{Output}: {a ranked list of likely root cause configuration options}
\vspace{-4mm}%
recommendOptions($\mathit{V_{old}}$, $\mathit{V_{new}}$, $\mathit{predMap}$)\\
\begin{algorithmic}[1]
\STATE $\mathit{optionMap}$ $\leftarrow$ new Map$\langle$Option, Float$\rangle$
\FOR{each $\langle$$\mathit{p_{old}}$, $\mathit{p_{new}}$$\rangle$ in $\mathit{predMap}$.keys()}
\STATE $\mathit{v}$ $\leftarrow$ $\mathit{predMap}$[$\langle$$\mathit{p_{old}}$, $\mathit{p_{new}}$$\rangle$]
\IF{$\mathit{p_{old}}$ $\neq$ $\mathit{null}$}
\STATE $\mathit{options_{old}}$ $\leftarrow$ getAffectingOptions($\mathit{p_{old}}$, $\mathit{V_{old}}$)
\STATE $\mathit{v}$ $\leftarrow$ $\mathit{v}$ $\times$ getExecutedStmtNum($\mathit{p_{old}}$, $\mathit{V_{old}}$, $\mathit{T_{old}}$)
\FOR{each Option $\mathit{option}$ in $\mathit{options_{old}}$}
\STATE $\mathit{optionMap}$[$\mathit{option}$] $\leftarrow$ $\mathit{optionMap}$[$\mathit{option}$] + $\mathit{v}$
\ENDFOR
\ENDIF
\IF{$\mathit{p_{new}}$ $\neq$ $\mathit{null}$}
\STATE $\mathit{options_{new}}$ $\leftarrow$ getAffectingOptions($\mathit{p_{new}}$, $\mathit{V_{new}}$)
\STATE $\mathit{v}$ $\leftarrow$ $\mathit{v}$ $\times$ getExecutedStmtNum($\mathit{p_{new}}$, $\mathit{V_{new}}$, $\mathit{T_{new}}$)
\FOR{each Option $\mathit{option}$ in $\mathit{options_{new}}$}
\STATE $\mathit{optionMap}$[$\mathit{option}$] $\leftarrow$ $\mathit{optionMap}$[$\mathit{option}$] + $\mathit{v}$
\ENDFOR
\ENDIF
\ENDFOR
\RETURN $\mathit{optionMap}$.sortedKeys()
\vspace{-2mm}
\end{algorithmic}
\caption{Algorithm for recommending configuration options.
\label{fig:recommend}
}

\todo{Each entry of optionMap needs to be initialized to 0.}

\todo{The algorithm of Figure~\ref{fig:recommend}, together with that of
  Figure~\ref{fig:identify}, seem too complicated to me.  For example,
  pairs are put in predMap, but the correspondence between the elements of
  those pairs is not used.  I think that both figures can be replaced by
  something much shorter (and clearer to me):
}

\begin{Verbatim}
deviation(p1, T1, p2, T2):
  result = | \phi(p, T) - \phi(p_other, T_other) |
  if result < \delta
    result = 0
  return result

recommendOptions(V_old, V_new, stmtMap)
  optionMap <- new Map<Option, Float>
  for p_old in getPredicates(T_old):
    v <- deviation(p_old, T_old, stmtMap[p_old], T_new)
    ... [lines 5-9 of current algorithm]
  for p_new in getPredicates(T_new):
    v <- deviation(stmtMap^{-1}[p_new], T_old, p_new, T_new)
    ... [lines 12-16 of current algorithm]
  return optionMap.sortedKey()
\end{Verbatim}

\end{figure}


%  LocalWords:  getAffectingOptions getExecutedStmtNum recommendOptions
