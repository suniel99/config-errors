\input{matchalgorithm}

In this step, \ourtool compares two execution traces
from two program versions, and identifies the
control flow differences between them. \ourtool focuses on the
recorded behavior of each predicate.
First, it statically
matches each predicate in the old
source code execution trace to its counterpart in the new source code
(Section~\ref{sec:match_predicate}).
Then, it identifies all predicates that
behave differently across the execution traces (Section~\ref{sec:identify_diff}).


\subsubsection{Matching Predicates across Versions}
\label{sec:match_predicate}

For each predicate recorded in the old execution trace,
\ourtool matches it in the new program version to identify
its possibly updated counterpart.
The predicate-matching process proceeds in two steps.
First, \ourtool finds corresponding methods.
Then, \ourtool matches predicates within matching methods.

To match methods, \ourtool uses
the first of these two strategies that succeeds:

%, and then
%identifies its runtime behaviors in the undesired execution profile.

\vspace{-1mm}

\begin{enumerate}
\item \textbf{Identical method name.} Return a method with the identical
fully-qualified name in the new version.
\item \textbf{Similar method content.} Return the method with
the most similar content in the new version. Given
a method in the old program version, \ourtool
uses the algorithm shown in Figure~\ref{fig:matching}
(details are discussed below) to match it
to \textit{every} method in the new program version, and then
chooses the method with the most matched statements
(in the new program version).

After running the matching algorithm, \ourtool further checks the ratio of
matched statements in the old method, and discards method candidates whose
matching ratio is below a threshold (default value: 0.9).
\end{enumerate}


If there is no match for the declaring method in the new program
version, \ourtool concludes that the predicate cannot be
matched. Otherwise, \ourtool runs the algorithm
in Figure~\ref{fig:matching} (or looks up a cached version of the result)
to establish the mapping between
instructions, and then returns the matched instruction of the
predicate (or null if the predicate cannot be matched).


\paragraph{Statement-matching algorithm}

The algorithm in Figure~\ref{fig:matching} is inspired by
a well-established program differencing algorithm, called
JDiff~\cite{Apiwattanapong:2004}. The original JDiff
algorithm is based on a method-level representation
(called hammocks) that models the object-oriented features.\
It works in a hierarchical way by first identifying matched
classes and then matched method pairs, and uses
textual similarity to compare two program statements. By contrast, our
algorithm directly works on the bytecode, using program control flow graph
to establish the matching between statements.

In Figure~\ref{fig:matching}, \ourtool first constructs the control
flow graphs of two given methods (lines 2--3), then pushes their
entry nodes (a synthetic node for each method) to a stack (line 5), which retains
the next statement pair for comparison. The algorithm repeatedly
pops each statement pair from the stack (line 7), and
decides whether the two statements are matched (line 12).  To avoid infinite
loop, the algorithm first checks whether the next statement for comparison
has been compared before (lines 8--9). 

The algorithm decides whether two statements are matched by using
the matched($\mathit{s}$, $\mathit{s'}$) auxiliary method. Method
matched($\mathit{s}$, $\mathit{s'}$) returns true if both
$\mathit{s}$ and $\mathit{s'}$ have the same statement type (i.e.,
the same instruction type in bytecode), and if $\mathit{s}$ and
$\mathit{s'}$ are field-accessing or method-invoking statements,
they access the same field or invoke the same method.
We use such approximate matching since \ourtool directly works
on bytecode rather than source code. The approximate matching
tolerates small differences
occurs between two versions, such as changes to constant values.


If two statements are matched, the algorithm saves them in the
result map (line 13). Otherwise,
the algorithm follows the control flow graph to compare a statement with
the next $lh$ statements, and checks whether any two statements can be
matched (lines 16--22). Doing so permits the algorithm to tolerate some small
changes in the method code, and attempts to match as many statements as possible.

When two matched statements are found  (stored in
the $\mathit{matchedPair}$ variable in lines 14 or 21),
the algorithm pushes every pair of
their successive statements onto the stack (line 27).
It terminates after every statement has been attempted to match.


%\input{identifyalgorithm}

\subsubsection{Identifying Behaviorally-Deviated Predicates}
\label{sec:identify_diff}

With the predicate matching information, \ourtool 
identifies predicates that behave differently
between two versions. 

Given an execution trace $\mathit{T}$,
\ourtool characterizes a predicate $\mathit{p}$'s behavior by how often
it is evaluated (i.e., the number of observed executions),
and how often it is evaluated to true (i.e., the true ratio).
The true ratio is an important characteristic of a predicate's behavior,
but it is less dependable
if fewer times the predicate has been executed.

\ourtool uses a function $\phi$ to combine both true ratio
and number of executions in a standard way by computing their harmonic mean.

%characterize a predicate's behavior.
%The $\phi$ metric combines sensitivity (informally, the need
%for multiple observations) and specificity (informally, the
%true ratio in a standard way by computing their harmonic mean.
%As empirically demonstrated in our previous work~\cite{Zhang:2013:ADS},
%the metric $\phi$ provides a good characterization of a predicate's behavior.

\vspace{-2mm}

\begin{equation*}
 \|\phi|(p, T)= \cfrac{2}{\frac{1}{\|trueRatio|(p, T)} + \frac{1}{\|totalExecNum|(p, T)}}
\end{equation*}

\vspace{-1mm}

In $\phi(p, T)$, $\|trueRatio|(p, T)$ returns the ratio of executions of the
predicate $p$ that evaluated to true in $T$,
and $\|totalExecNum|(p, T)$ returns the the total
number of observed executions of predicate $p$ in $T$.
To smooth corner cases, if a predicate $p$ is not executed in $T$ 
(i.e., $\|totalExecNum|(p, T) = 0$), or
a predicate $p$'s true ratio is 0 (i.e., $\|trueRatio|(p, T) = 0$),
then $\phi(p, T)$ returns 0.
%and if a predicate $p$'s true ratio is 0, 
%then $\phi(p, t)$ returns $1/\|totalExecNum|(p, t)$.
Finally, we let $\phi(null, T) = 0$ for all $T$.

%The algorithm is shown in Figure~\ref{fig:identify}.
%It first iterates every predicate in the old execution trace (line 2),
%computes its metric value as the initial deviation value (line 3), and
%checks whether it has a matched predicate executed in the
%new execution (lines 4--5). If so, it updates the
%initial deviation value (line 6). The algorithm further filters away
%predicate pairs whose deviation value is less than a predefined $\delta$ (lines 8 and 15). The algorithm next iterates through the executed predicate list
%in the new execution trace, and identifies the predicate without any
%corresponding predicate in the old execution trace (lines 13--18).

Given two matched predicates $p_{1}$ and $p_{2}$ from two different execution traces $T_{1}$ and $T_{2}$,
\ourtool uses the {deviation} function defined in Figure~\ref{fig:recommend}
to compute the behavioral deviation value.
In Figure~\ref{fig:recommend}, the {deviation} function
 discards a predicate whose behavioral deviation value is less than
a pre-defined threshold (line 2). This is for tolerating small non-determinism
during program execution and
making \ourtool only focus on predicates with substantial
behavioral differences.

The identified behaviorally-deviated predicates indicate different
control flow taken between two versions under the same input
and configuration. Such control flow differences provide evidence of
which part of the program might be behaving unexpectedly and why.

%The output of the algorithm in this step contains three categories
%of matched predicate pairs:
%(1) predicates that are only executed in the
%old version. For each of those predicates, there is no matched predicate
%for such predicate in the new version, or the matched predicate
%is not executed; (2) predicates that are only executed
%in the new version. For each of those predicates, there is
%no matched predicate in the old version, or the matched predicate
%is not executed. (3) predicates that
%are executed in both versions but exhibit different
%behaviors. For each predicate pair, \ourtool sorts computes
%its deviation score between versions.


%is any path not taken by the actual
%program execution that starts at a conditional
%branch instruction for which the branch condition
%is affected by one or more configuration options.


%  LocalWords:  JDiff
