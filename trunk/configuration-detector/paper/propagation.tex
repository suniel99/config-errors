For each configuration option, Configuration Propagation Analysis statically determines
its affected \textit{predicates}. In our context, a \textit{predicate}
is a boolean expression in a conditional or loop statement, whose evaluation result
determines whether to execute the following statement or not.
A predicate's runtime outcome affects the program control flow.
\ourtool focuses on identifying and monitoring 
configuration option-affected control flow
rather than the values, for two reasons. First, control flow 
often propagates the majority of configuration-related effects
and determines a program's execution path, while
the value of a specific expression may be largely input-dependent.
Second, it simplifies reporting because the outcome of a program predicate can only be
either true or false.  Nevertheless, program predicate is not the only
abstraction our technique can use. Our experiments (Section~\ref{sec:evaluation}),
empirically demonstrate that choosing other abstractions,
such as monitoring statement-level coverage
or method-level invariants, yields less accurate results.


To identify the predicates affected by a configuration option, a straightforward
way is to use program slicing~\cite{Horwitz:1988} to compute
a forward slice from the initialization statement of a
configuration option. Unfortunately, traditional slicing is impractical
because it includes too much of the program.  This is due to conservatism
(for example, in handling pointers) and to following both data and control
dependences.

%\todo{I propose to cut this paragraph; it feels redundant with the above.}
%First, traditional slicing does not distinguish flows along
%pointers from flows along values; thus, a resulting slice includes all statements that
%\textit{may} affect a point of interest and often grows too large. Second,
%many statements included in the resulting slice are indirectly
%affected by a configuration option value but may not be pertinent
%to the task of diagnosing a configuration error.
%Monitoring the control flow of such indirectly-affected statements 
%and then linking their behaviors to specific configuration option values
%may lead to less accurate diagnosis.

Figure~\ref{fig:example} illustrates
this problem.  Traditional slicing concludes that the predicates
in lines 104, 312, and 315 are affected by the configuration option \CodeIn{maxsize}.
However, the predicates in lines 104 and 315, though possibly
affected by the \CodeIn{maxsize}, are actually irrelevant
to \CodeIn{maxsize}'s value. That is, the value of \CodeIn{maxsize}
controls the length of a generated a sequence rather
than deciding whether a sequence has an active flag (line 104) or
a sequence has been executed before (line 315).

%such slightly-related predicates (computed by full slicing) and linking their behaviors with a
%configuration option may decrease the diagnosis accuracy.
%This has also been confirmed by our experiments.

%However, if the provided input changes the workflow,
%instead of all data flow into it. 

To address this limitation, our technique uses thin
slicing~\cite{Sridharan:2007}, which includes
\textit{only} statements that are \textit{directly} affected by a configuration option.
Different from traditional slicing, thin slicing
focuses on statements that flow values to the seed (here, a
seed is the initialization statement of a configuration option), ignoring the 
control flow dependencies as well as the uses of
base pointers. By doing this, thin slicing improves the relevance
of the slice by only including the statements that compute
and copy a value to a configuration option.
This property separates
pointer computations from the flow of configuration option value,
naturally connects a configuration option with its
directly affected statements, and makes thin slicing
especially attractive.
For example, in the code excerpt of Figure~\ref{fig:example},
a forward thin slice computed for \CodeIn{maxsize}
only includes the predicate in line 312.
Section~\ref{sec:evaluation}, 
also empirically compares traditional slicing with
thin slicing and demonstrates that thin slicing is a better choice
than traditional slicing.

%When Randoop is used to generate tests for different inputs (here,
%input mean programs under test), the created tests (method-call
%sequence at line 12) would be dramatically different.
%However, for similar inputs, the program execution flow should
%be similar.


%In fact, there is another configuration option $\blacksquare$
%that affect line 6.

% 
