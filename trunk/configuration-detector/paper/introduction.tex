
\section{Introduction}
\label{sec:introduction}

Modern software is extraordinarily complex. Many applications have a large
number of configuration options that offer users great flexibility to
customize their behaviors. This flexibility has a cost: when something
goes wrong, diagnosing a configuration error can be both time-consuming
and frustrating. Technical support contributes 17\% of the total cost of ownership of
today's desktop computers~\cite{confevidence}, and troubleshooting misconfigurations
is a large part of technical support.

Software misconfigurations are often exhibited by an application unexpectedly terminating
(i.e., crashing errors) or producing an incorrect output (i.e., non-crashing errors). While an ideal application would always
output a helpful error message when such events occur, it is unfortunately
the case that such messages are often cryptic, misleading, or even non-existent~\cite{}.
Thus, users must search manuals, FAQs, and online forums to find potential
solutions to the problem. %$\blacksquare$ this process is frustrating..

\subsection{Example}


$\blacksquare$ also lead to spurious bug reports.

A users should not be experted and should not be expected to provide
an testing oracle.

To the best of our knowledge, this problem cannot be diagnosed by
existing configuration error localization approaches.

not everyone has the technical skill to use this solution.
And even if one does, using the xxx, findinig, and moving xx
counter past the end of the loop can be a tedious and annoying process.

Assume the crash

Our tool provides contextual information.


%\vspace{1mm}
%\noindent \textbf{\textit{Our technique.}} 

\subsection{Diagnosing Configuration Errors}

The process of diagnosing configuration errors can be divided into two
separate tasks: identifying which specific configuration option is
responsible for the unexpected behavior, and determining how to fix that
configuration option. In this paper, we address the former task: finding
the root cause of a configuration error.
%, and leave the later task
%of fixing

\textbf{Our technique}

$\blacksquare$ We assume that the error is know, i.e., the error has
been previously encountered ... Thus, the problem of explaining a
configuration error on a different environment can be reduced to
identifying that the xxx is in a state similar to a xxx good state
on the reference computer for which a solution is known.

\ourtool helps mitigate such problems.

We have developed a tool, called \ourtool, that uses xxx
to identify the likely root cause of a configuration error.
When a user or administrator wishes to diagnose a
problem such as a crash or incorrect output, she
reproduces the problem xxxxon a platform $\blacksquare$
where \ourtool tracks the causal dependencies between
configuration options and the program behavior.
\ourtool produces an ordered list of the 
configuration options most likely to have caused the exhibited
problem.

While xxx analysis takes a few minutes for a complex application,
automated error diagnosis is still considerably faster and
less labor-intensive than manual debugging or searching
through other resources.

\ourtool tracks dependencies introduced by both data and
control flow. It propagates dependencies among xxx


Most prior work on configuration debugging has relied
on large user communities or on modifying the program’s execution
environment $\blacksquare$ focusing on crashing errors.

The core of our approach is to xxx. 
We envision this being done by the developers
at release time. When a user encounters an error, they can
use the error message to query this database, perhaps via a web
service.

The developers provide a profile database, which users can use
to query. The users can also enrich the database, providing their
own examples. even a single run

$\blacksquare$ our technique is lightweighted.
Our technique requires no alterations to
the JVM or standard library. This distinguishes our work from
competing techniques such as dynamic taint tracking.

Previous technique focuses exclusively on configuration errors
where the value of an option is wrong and this causes a program
to fail in a deterministic way with an error message, while
ignoring configuration problems that manifest themeselves as
silent failures.

We envision that this technique xxx could be performed by
the software developers; users would need only to provide
the profiles xxx to back a diagnosis.

Our technique, on its own, does not require a user to specify
\textit{why} and \textit{how} the program fail.
Our technique also genertes concise descriptions of the problem
wuith a given option, as is ranking possible diagnoses.

%\vspace{1mm}
%\noindent \textbf{\textit{Evaluations.}} 

\subsection{Evaluation}

Our results show that \ourtool identifies the correct
root causes of most configuration errors. xxxx top 3,
it lists the correct root cause as the top 3 xxx.
\ourtool takes less than xxx minutes for diagnosing
one configuration error, making it an attractive alternative
to manual debugging.

\ourtool outputs an ordered list of probable root causes.
Each entry in the list is a user-settle configuration option;
our results show that \ourtool typically outputs
the actuall responsible configuration option as the top 3 in the list.

This allows \ourtool user to focus on a few specific configuration
options when deciding how to fix the problem. By finding the
needle in the haystack, \ourtool can be an attractive ...

%\vspace{1mm}
%\noindent \textbf{\textit{Contributions.}}

\subsection{Contributions}
This paper makes the following contributions:

\begin{itemize}
%\item \textbf{Problem.} To the best of our knowledge, we are the first to address
%the invalid thread access error detection problem for multithreaded GUI applications.

\item \textbf{Technique.} We present a technique to diagnose
software configuration errors. Our technique uses static analysis,
dynamic profiling, and statistical inference to link the
erroneous behavior to specific configuratio options (Section~\ref{sec:technique}).


\item \textbf{Implementation.} We implemented our technique 
for Java software (Section~\ref{sec:implementation}). Our tool implementation is publicly available at
\url{http://config-errors.googlecode.com}.


\item \textbf{Evaluation.} We applied \ourtool to diagnose
\errors crashing and non-crashing configuration errors in \subjectnum
real-world Java software. The results
show the usefulness of the proposed technique (Section~\ref{sec:evaluation}).

\end{itemize}



