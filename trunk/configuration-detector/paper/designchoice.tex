\begin{figure}[t]
\setlength{\tabcolsep}{.74\tabcolsep}
\small{
\begin{tabular}{|l|c|c||c|}
\hline
 Error ID. & \multicolumn{3}{|c|}{Rank of the Actual Root Cause} \\
  %& \multicolumn{3}{|c|}{Different Comparison Profile Selection Strategy} \\
\cline{2-4}
 Program & All Profiles& Random Selection&  Similarity-Based\\
 \hline
\hline
\multicolumn{4}{|l|}{Non-crashing errors}   \\
 \hline
 1. Randoop & 1 & 2 & 1\\
 2. Weka & 7 & 6 & 1\\
 3. JChord & 16 & 19 & 2\\
 4. Synoptic & 1 & 1 & 1\\
 5. Soot & 13 & 13 & 3\\
\hline
Average & 7.6 & 8.2 & 1.6 \\
\hline
\hline
\multicolumn{4}{|l|}{Crashing errors}   \\
\hline
 6. JChord & 1 & 1 &1\\
 7. JChord & 1 & 1 &1\\
 8. JChord & 17 & 17 &17\\
 9. JChord & 1 &  1&1\\
 10. JChord & 15 & 15 &15\\
 11. JChord & 16 & 16 &16\\
 12. JChord & 1 & 1 &1\\
 13. JChord & 25 & 25 &1\\
 14. JChord & 8 & 8 &8\\
\hline
Average & 9.4 & 9.4 & 6.7\\
\hline
\end{tabular}
}
\Caption{{\label{tab:selection} Comparison with different execution profile selection
strategies (Section~\ref{sec:choices}).
The last column ``Similarity-based'' is the selection strategy
used in \ourtool, and the data in that column is taken from Figure~\ref{tab:results}.}}
\end{figure}

We investigate the effects of:

\begin{itemize}
\item using traditional full slicing~\cite{Horwitz:1988} rather
than thin slicing~\cite{Sridharan:2007} in the Configuration
Propagation Analysis step (Section~\ref{sec:prop}) to compute the affected predicates.
Figure~\ref{tab:results}  (Column ``Full Slicing'') shows the results.
\item varying the comparison execution profiles from the pre-built database.
In particular, we compare the similarity-based selection strategy used in \ourtool
 (Section~\ref{sec:similar}) with two alternatives: selecting
all available profiles in the database, and
randomly selecting the same number of profiles as \ourtool used from the database.
Figure~\ref{tab:selection} shows the results.
\end{itemize}


$\blacksquare$ talk about the full slicing, why it is not
effective. it involves too much details, noises

the imprecision the major reason, //same reason as the thin slicing paper..
First, traditional slicing does not distinguish flows along
pointers from flows along values; thus, a resulting slice includes all statements that
\textit{may} affect a point of interest and often grows too large. Second,
many statements included in the resulting slice are indirectly
affected by a configuration option value but may not be pertinent
to the task of diagnosing a configuration error.
Monitoring the control flow of such indirectly-affected statements 
and then linking their behaviors to specific configuration option values
may lead to less accurate diagnosis.

Furthermore,
modern programs typically rely heavily on well-tested data structures
provided by standard libraries, whose internal details rarely
concern the end-user programmer. For these common cases, the
backwards slice presents far too much information for the task at
hand.


We can see that varying the comparison strategy can result in
substantially different effects on the diagnosis results,
depending on the application being analyzed. Diagnosing
a non-crashing error is more sensitive in selecting similar
comparison execution profiles$\blacksquare$ than diagnosing
a crashing error.
For the \crash crashing errors, the only difference yielded
from using different profile selection strategies is on
the error 13. $\blacksquare$

Why random selection does not work?
comparison irrelevant parts, executing the totally different parts.
$\blacksquare$, example irrelvant comparison

Why crashing errors are better? chopping to the predicates results
in more similar, a few times.

