% -*- mode:LaTeX -*-

As shown in Figure~\ref{tab:results},
\ourtool is highly effective in pinpointing the root cause of
misconfigurations. For all \noncrash non-crashing errors
and 5 of the \crash crashing errors, it lists the actual root cause as one of the top 3 options. 


\paragraph{Non-crashing configuration errors.}

\ourtool is particularly effective in diagnosing non-crashing configuration
errors,
which are not supported by most other tools.
The average rank of the root cause
in \ourtool's output is 1.6.
The primary reason is
\ourtool's ability to identify the behaviorally-deviated predicates through
execution profile comparison. The top-ranked deviated predicates often provide
useful clues about what parts of a program might be abnormal and why.

We use the non-crashing error in Weka as an example to illustrate
this point. 
Weka's decision tree implementation is highly tuned, achieving 70--90\% accuracy on
its included examples. However, its accuracy drops to 62\%
on a different dataset we experimented on. We used \ourtool to diagnose this
problem by first building a database by running Weka on its examples, and
then
obtaining the undesired execution profile by running it on our dataset. As a result,
\ourtool outputs the following report (only the top option is shown):

\vspace{-1mm}

\begin{CodeOut}
\begin{alltt} 
  Suspicious configuration option: m\_numFolds

  It affects the behavior of predicate:
  "numFold < numInstances() \% numFolds"
  (line 1354, class: weka.core.Instances) 

  This predicate evaluates to true:
    20\% of the time in normal runs (4 observations)
    70\% of the time in the undesired run (10 observations)

\end{alltt}
\end{CodeOut}

\vspace{-4mm}

The above report reveals an important fact about the low accuracy.
The predicate \CodeIn{numFold $<$ numInstances() \% numFolds} controls
the depth of a decision tree. Its
true ratio is substantially higher in the undesired execution
than in normal executions. A higher true ratio leads
to a deeper tree that is more likely to overfit the training
data and yield low accuracy on the testing data.
To resolve this problem, we changed \CodeIn{m\_numFolds}
value from 2 to 3 to reduce the tree depth, and
gained a 5\% performance increase.

%achieved
%Changing the default value of m\_numFolds from 3 to 2 leads to
%an immediate increase of 5\% improvement

\paragraph{Crashing configuration errors.}

%Although \ourtool ranked the actual root course of several crashing errors lower, 
Crashing errors are often easy for a user to diagnose.
This is because a crashing error often produces a stack trace or error message with valuable diagnosis clues.
In fact, for the crashing errors selected by the ConfAnalyzer authors, the
user is always led to the root cause by the program output,
without the need for further analysis.
For error \#6, JChord throws a \CodeIn{NoClassDefFoundError}\todo{For what class?}
which reminds the user that a non-existant class might be provided.
For error \#7, JChord outputs an error message of ``Could not find main class [...]
or main method in that class'' that explicitly informs the user that
the configuration option to specify a main class might be wrong.
For error \#8--13,
JChord outputs the relevant configuration option in its error message.
For error \#14, JChord throws a \CodeIn{ClassNotFoundException}\todo{For
what class?} that reminds the user to check the classpath setting.  


%Consider the 4 errors in in Figure~\ref{tab:results} for which \ourtool
%does not rank the root cause first. For errors \#8,
%\#10, and \#11, 
%JChord outputs the relevant configuration option value in the
%error message.  
%\todo{Is the same true for
%  ConfAnalyzer?  Say explicitly.  
\todo{Mike wants to review this text once it is
  written.}

Between the program output and \ourtool, the user is led directly to the
root cause
and ConfAnalyzer) and the program output.

If a user were to unrealistically ignore program output, then \ourtool is less effective
in diagnosing crashing errors (the average rank of the root cause
in \ourtool's output is 6.7) than non-crashing errors (average rank: 1.6)
%For 4 crashing errors, the actual causes are ranked below the top 3 options.
This is a direct result of lacking enough predicate behavior observations,
since most crashing errors occur soon
after the program is launched.  Many predicates are
only executed once, so their $Deviation$ scores
 (Section~\ref{sec:deviation}) turn out to be the same; and the
 BFS-distance-based heuristic to resolve ties (Section~\ref{sec:linking}) only
works half the time.


%considers configs closer to the erroneous behavior to be more
%likely to lead to the root cause than those farther away

%$\blacksquare$ the configuration option has
%a long propagation chain, and seems hard for \ourtool
%to diagnose correctly. no statistical significance...



%$\blacksquare$
%Thus, the root cause gets
%ranked lower in the list. This ordering is a direct result
%of the heuristic discussed in Section XXX that 

%== imprecise of thin slicing, particularly when dealing with containers,






%%  LocalWords:  misconfigurations Weka Weka's numFolds numFold overfit
%%  LocalWords:  numInstances JChord ClassNotFoundException classpath BFS
