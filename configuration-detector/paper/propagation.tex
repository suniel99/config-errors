For each configuration option, this step statically determines
its affected \textit{predicates}. In our context, a \textit{predicate}
is a boolean expression in a conditional or loop statement, whose evaluation result
decides whether to execute the followed statement or not.
A predicate's rutnime outcome affects the program control flow.
In \ourtool, we focus on identifying and monitoring 
configuration option-affected control flow in a program
rather than the value in an arbitrary data point based on the
following two observations. First, control flow 
often propagates the majority of configuration-related affects
and is essential to a program's execution path, while
the value of a specific data flow point is largely input-dependent.
And second, the outcome of a program predicate can only be
either true or false; thus, the number of recorded states in monitoring
affected control flow is far less than monitoring arbitrary
data values.  Nevertheless, program predicate is not the only
abstraction our technique can use. In our experiments (Section~\ref{sec:evaluation}),
we empirically demonstrate that choosing other abstractions
such as monitoring statement-level coverage
or method-level invariant yields less accurate results.


To identify the predicates affected by a configuration option, a straightforward
way is using program slicing~\cite{Horwitz:1988} to compute
a forward slice from the initialization statement of a
configuration option. Unfortunately, traditional slicing has
several limitations that prevent it from being used.
First, traditional slicing does not distinguish flows along
pointers from flows along values; thus, a resulting slice includes all statements that
\textit{may} affect a point of interest and often grows too large. Second,
many statements included in the resulting slice are indirectly
affected by a configuration option value but may not be pertinent
to the task of diagnosing a configuration error.
Monitoring the control flow of such indirectly-affected statements 
and then linking their behaviors to specific configuration option values
may lead to less accurate diagnosis.

Take the code in Figure~\ref{fig:example} as an example to illustrate
this problem.  Traditional slicing concludes that the predicates
in lines 104, 312, and 315 are affected by the configuration option \CodeIn{maxsize}.
However, the predicates in lines 104 and 315, though possibly
affected by the \CodeIn{maxsize}, are actually irrelevant
to \CodeIn{maxsize}'s value. That is, the value of \CodeIn{maxsize}
controls the length of a generated a sequence rather
than deciding whether a sequence has an active flag (line 104) or
a sequence has been executed before (line 315).

%such slightly-related predicates (computed by full slicing) and linking their behaviors with a
%configuration option may decrease the diagnosis accuracy.
%This has also been confirmed by our experiments.

%However, if the provided input changes the workflow,
%instead of all data flow into it. 

To address this limitation, our technique uses thin
slicing~\cite{Sridharan:2007} as a manner to include
\textit{only} statements that are \textit{directly} affected by a configuration option.
Differing from traditional slicing, thin slicing
focuses on statements that flow values to the seed (here, a
seed is the initialization statement of a configuration option), ignoring the 
control flow dependencies as well as the uses of
base pointers. By doing this, thin slicing improves the relevance
of the slice by only including the statements that compute
and copy a value to a configuration option.
This property separates
pointer computations from the flow of configuration option value,
naturally connects a configuration option with its
directly affected statements, and makes thin slicing
especially attractive.
For example, in the code excerpt of Figure~\ref{fig:example},
a forward thin slice computed for \CodeIn{maxsize}
only includes the predicate in line 312.
In Section~\ref{sec:evaluation}, 
we also empirically compare traditional slicing with
thin slicing, and demonstrate that thin slicing is a better choice
over traditional slicing.

%When Randoop is used to generate tests for different inputs (here,
%input mean programs under test), the created tests (method-call
%sequence at line 12) would be dramatically different.
%However, for similar inputs, the program execution flow should
%be similar.


%In fact, there is another configuration option $\blacksquare$
%that affect line 6.

% 
