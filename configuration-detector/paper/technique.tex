\section{Technique}
\label{sec:technique}

We model configurations as a set of key-value pairs, where
the keys are strings and the values have arbitrary type. This is
a common abstraction offered
by the POSIX system environment, the Java Properties API,
and the Windows registry.


\subsection{Overview}

Figure~\ref{fig:workflow} sketches the high-level workflow of our technique.
Our technique takes as input a Java program and its configuration options.
It first performs a propagation analysis to identify
the affected predicates for each configuration option (Section~\ref{sec:prop}).
After that, our technique \textit{selectively} instruments
the program on the affected predicates. 
To diagnose an error, users run the instrumented program
with the error-revealing inputs and configurations
 to obtain an execution
profile (Section~\ref{sec:profiling}).
Then, our technique uses the obtained execution profile
to identify the behaviorally-deviated predicates and their
responsible options as the root causes (Section~\ref{sec:analysis}).

%The output error report is a ranked list
%of suspicious configuration options that may cause the exhibited problem.

%, linking each configuration
%to its affected predicates


\begin{figure*}[!]
  \centering
  \includegraphics[scale=0.600]{architecture}
  \vspace*{-2.0ex}\caption {{\label{fig:workflow} The workflow of our configuration error diagnosis technique.
Phases ``Instrument'' and ``Run'' correspond to the Configuration Behavior Profiling step in Section~\ref{sec:profiling}.
The other two phases: ``Propagation Analysis'' and ``Deviation Analysis'' correspond to steps in Section~\ref{sec:prop} and Section~\ref{sec:analysis}, respectively.
}}
\end{figure*}

\subsection{Configuration Propagation Analysis}
\label{sec:prop}
\input{propagation}

\subsection{Configuration Behavior Profiling}
\label{sec:profiling}
\input{profiling}


\subsection{Configuration Deviation Analysis}
\label{sec:analysis}
\input{deviation}


\subsection{Discussions}

We next discuss some design issues in \ourtool.

\vspace{1mm}
\noindent \textbf{Differences between program inputs and configuration options.}
A configurable software system exposes a range of configuration
options that permit users to
customize its behaviors. Broadly speaking,
a configuration option can be seen as a special program input
(or \textit{meta-}input), which needs to be set before the
software is used. Unlike porgram inputs, a configuration option is often
used to control a program's execution rather than
produce results for a certain task, and thus
is often independent of the concrete input values that a user might provide.


\vspace{1mm}
\noindent \textbf{Why not use traces from unit test executions?}
\ourtool's database stores traces from correct 
executions. However, it needs every trace to be complete
(i.e., executing from the main method).
\ourtool does not use traces from unit test executions
because erroneous executions
in fielded software must start from its main method, while
a unit test merely checks the correctness
of a single program component, and often produces
an incomplete trace that is not representative for
the whole program workflow. 



\vspace{1mm}
\noindent \textbf{Why not store traces from failing executions in the database?}
We envision the trace database is built by developers at release.
For a developer, it is more natural for her to provide correct execution
traces as debugging references, instead of
anticipating the possible errors a user may encounter.
$\blacksquare$
A broader question is which kind of informatin should be recorded
from program execution. 
In the design of \ourtool, we store the behavioral information
of each affected predicate from correct executions in the database,

%and empirically compared with two other abstractions (a coarser abstraction
%at the method level, and a finer abstract at the statement level).
%Investigating the trade-
%\ourtool uses predicate as the abstraction level,
%and emprically compares with two other abstractions . Investigating
%other abstraction levels remains as our future work.

\vspace{1mm}
\noindent \textbf{What if a similar trace is not available?}
\ourtool's effectiveness largely depends on the availability of
similar traces from the database. For a given erroneous trace, lacking a similar
trace in \ourtool's database may lead \ourtool to produce
less useful reasults, and also indicates the testing inadequancy,
We list approaches to remedy this problem as our future work. One
possible way is to synthesize a new execution, either by
generating new input for the program or by directly mutating a
existing execution itself~\cite{sumnerICSE2011}.


%Why dynamic slicing is not usable? No seed statement, and great overhead. Using JSlicer incurs
%a great overhead. It needs to track every instruction and
%perform synchronization when dependence graph is updated.

%Our technique can be seen as a way to reduce overhead,
%including selective profiling, and static pre-processing
%techniques.

