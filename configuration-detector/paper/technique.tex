\section{Technique}
\label{sec:technique}

We model a configuration as a set of key-value pairs, where
the keys are strings and the values have arbitrary type. This is
a common abstraction offered
by the POSIX system environment, the Java Properties API,
and the Windows registry.


\subsection{Overview}

Figure~\ref{fig:workflow} sketches the high-level workflow of our technique.
Our technique takes as input a Java program and its configuration options.
It first performs a propagation analysis to identify
the affected predicates for each configuration option (Section~\ref{sec:prop}).
After that, our technique \textit{selectively} instruments
the program on the affected predicates. 
To diagnose an error, a user runs the instrumented program
with the error-revealing input and configuration
to obtain an execution trace (Section~\ref{sec:profiling}).
Then, our technique analyzes the obtained trace
to identify the behaviorally-deviated predicates and their
responsible options, and reports these to the user (Section~\ref{sec:analysis}).

%The output error report is a ranked list
%of suspicious configuration options that may cause the exhibited problem.

%, linking each configuration
%to its affected predicates


\subsection{Configuration Propagation Analysis}
\label{sec:prop}
\input{propagation}

\subsection{Configuration Behavior Profiling}
\label{sec:profiling}
\input{profiling}


\subsection{Configuration Deviation Analysis}
\label{sec:analysis}
\input{deviation}


\subsection{Discussion}

We next discuss some design issues in \ourtool.

\vspace{1mm}
\noindent \textbf{Differences between program inputs and configuration options.}
A configurable software system exposes a range of configuration
options that permit users to
customize its behaviors. Broadly speaking,
a configuration option can be seen as a special program input
(or \textit{meta-}input), which needs to be set before the
software is used. Unlike porgram inputs, a configuration option is often
used to control a program's execution rather than
produce results for a certain task, and thus
is often independent of the concrete input values that a user might provide.


\vspace{1mm}
\noindent \textbf{Why not use traces from unit test executions?}
\ourtool's database stores correct traces from complete 
executions that start at the main method.
\ourtool does not use traces from unit test executions, which check the
correctness
of a single program component and produce
an incomplete trace that is not representative of
the whole program workflow. 



\vspace{1mm}
\noindent \textbf{Why not store traces from failing executions in the database?}
We envision the trace database is built by developers at release time.
It is more natural for a developer to provide correct execution
traces as debugging references, instead of
anticipating the possible errors a user may encounter.
%$\blacksquare$
%A broader question is which kind of informatin should be recorded
%from program execution. 
%In the design of \ourtool, we store the behavioral information
%of each affected predicate from correct executions in the database,

%and empirically compared with two other abstractions (a coarser abstraction
%at the method level, and a finer abstract at the statement level).
%Investigating the trade-
%\ourtool uses predicate as the abstraction level,
%and emprically compares with two other abstractions . Investigating
%other abstraction levels remains as our future work.

\vspace{1mm}
\noindent \textbf{What if a similar trace is not available?}
\ourtool's effectiveness largely depends on the availability of
similar traces from the database. For a given erroneous trace, lacking a similar
trace in \ourtool's database may lead \ourtool to produce
less useful reasults.  It also indicates inadequancy of the tests from
which the database was constructed.
Future work should remedy this problem. One
possible approach is to synthesize a new execution, either by
generating a new input for the program or by mutating an
existing execution~\cite{sumnerICSE2011}.


%Why dynamic slicing is not usable? No seed statement, and great overhead. Using JSlicer incurs
%a great overhead. It needs to track every instruction and
%perform synchronization when dependence graph is updated.

%Our technique can be seen as a way to reduce overhead,
%including selective profiling, and static pre-processing
%techniques.

