\section{Technique}
\label{sec:technique}

We model a configuration as a set of key-value pairs, where
the keys are strings and the values have arbitrary type. This
abstraction is offered
by the POSIX system environment, the Java Properties API,
and the Windows registry.


\subsection{Overview}

Figure~\ref{fig:workflow} sketches the high-level workflow of our technique.
Our technique takes as input a Java program and its configuration options.
It first performs a propagation analysis to identify
the affected predicates for each configuration option (Section~\ref{sec:prop}).
After that, our technique \textit{selectively} instruments
the program at the affected predicates. 
To diagnose an error, a user runs the instrumented program
with the error-revealing input and configuration
to obtain an execution profile (Section~\ref{sec:profiling}).
Then, our technique analyzes the obtained execution profile
to identify the behaviorally-deviated predicates and their
root causes, and reports these to the user (Section~\ref{sec:analysis}).

%The output error report is a ranked list
%of suspicious configuration options that may cause the exhibited problem.

%, linking each configuration
%to its affected predicates

\tinysqueeze

\subsection{Configuration Propagation Analysis}
\label{sec:prop}
\tinysqueeze
\input{propagation}

\tinysqueeze
\subsection{Configuration Behavior Profiling}
\label{sec:profiling}
\tinysqueeze
\input{profiling}


\tinysqueeze

\subsection{Configuration Deviation Analysis}
\label{sec:analysis}
\tinysqueeze
\input{deviation}


\subsection{Discussion}

In this paper, we focus specifically on configuration errors,
assuming the application code is correct, but the software		
is inappropriately configured so that it does not		
behave as desired. We next discuss some design issues in \ourtool.

%\vspace{1mm}
\vspace{0.5mm}
\noindent \textbf{Differences between program inputs and configuration options.}
We used our judgment to distinguish configuration options 
from other program inputs. A configuration option is
often used to control a program's control flow rather
than produce results, and is often supplied via a command-line
flag or configuration file.

%A configurable software system exposes a range of configuration
%options that permit users to
%customize its behaviors. %Broadly speaking,
%A configuration option can be seen as a special program input
%(or \textit{meta-}input), which needs to be set before the
%software is used. Unlike program inputs, a configuration option is often
%used to control a program's execution rather than
%produce results for a certain task, and thus
%is often independent of the concrete input values that a user might provide.


%\vspace{1mm}
\vspace{0.5mm}
\noindent \textbf{Why not use profiles from unit test executions?}
\ourtool's database stores correct profiles from complete 
executions that start at the main method.
\ourtool does not use profiles from unit test executions, which check the
correctness
of a single program component and produce
an incomplete execution profile that is not representative of
the whole program workflow. 



%\vspace{1mm}
\vspace{0.5mm}
\noindent \textbf{Why not store profiles from failing executions in the database?}
We envision the profile database is built by developers at release time.
It is more natural and easier for a developer to provide correct execution
profiles, instead of anticipating and enumerating the possible
errors a user may encounter.
\looseness=-1

\vspace{0.5mm}
\noindent \textbf{What if a similar execution profile is not available?}
\ourtool's effectiveness largely depends on the availability of
similar execution profiles from the database. For a given undesired execution profile, lacking a similar
profile in \ourtool's database may lead \ourtool to produce
less useful results.  It also indicates inadequacy of the tests from
which the database was constructed.
Future work should remedy this problem. One
possible approach is to synthesize a new execution, either by
generating a new input for the program~\cite{palus} or by mutating an
existing execution~\cite{sumnerICSE2011}.


%Why dynamic slicing is not usable? No seed statement, and great overhead. Using JSlicer incurs
%a great overhead. It needs to track every instruction and
%perform synchronization when dependence graph is updated.

%Our technique can be seen as a way to reduce overhead,
%including selective profiling, and static pre-processing
%techniques.

