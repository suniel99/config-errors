\section{Technique}
\label{sec:technique}

We model configurations as a set of key-value pairs, where
the keys are strings and the values have arbitrary type. This is
a common abstraction offered
by the POSIX system environment, the Java Properties API,
and the Windows registry.


\subsection{Overview}

Figure~\ref{fig:workflow} sketches the high-level workflow of our technique.
Our technique takes as input a Java program and its configuration options.
It first performs a propagation analysis to identify
the affected predicates for each configuration option (Section~\ref{sec:prop}).
After that, our technique \textit{selectively} instruments
the program on the affected predicates. 
To diagnose an error, users run the instrumented program
with the error-revealing inputs and configurations
 to obtain an execution
profile (Section~\ref{sec:profiling}).
Then, our technique uses the obtained execution profile
to identify the behaviorally-deviated predicates and their
responsible options as the root causes (Section~\ref{sec:analysis}).

%The output error report is a ranked list
%of suspicious configuration options that may cause the exhibited problem.

%, linking each configuration
%to its affected predicates


\begin{figure*}[!]
  \centering
  \includegraphics[scale=0.600]{architecture}
  \vspace*{-2.0ex}\caption {{\label{fig:workflow} The workflow of our configuration error diagnosis technique.
Phases ``Instrument'' and ``Run'' correspond to the Configuration Behavior Profiling step in Section~\ref{sec:profiling}.
The other two phases: ``Propagation Analysis'' and ``Deviation Analysis'' correspond to steps in Section~\ref{sec:prop} and Section~\ref{sec:analysis}, respectively.
}}
\end{figure*}

\subsection{Configuration Propagation Analysis}
\label{sec:prop}
\input{propagation}

\subsection{Configuration Behavior Profiling}
\label{sec:profiling}
\input{profiling}


\subsection{Configuration Deviation Analysis}
\label{sec:analysis}
\input{deviation}


\subsection{Discussions}

We next some design issues in \ourtool.

\vspace{1mm}
\noindent \textbf{Differences between program inputs and configuration options.}
A configurable software system permits users to
customize its behaviors before being used. Broadly speaking,
there is not any fundamental difference between a configuration option
value and a program input value. $\blacksquare$ a configuration option
value is more like a meta-input, which pre-defines the overall expected program
execution details and is usually fixed for a broad range of inputs.
By contrast, an input is more specific for a certain execution $\blacksquare$


\vspace{1mm}
\noindent \textbf{Why cannot use executions from unit tests?}
The pre-built database in \ourtool is designed to contain complete
execution traces, while a unit test that focuses on verifying the
isolated program component behavior in isolation often produces
an incomplete trace. In contrast, a crashing or non-crashing configuration
error from field software application often starts from the main method,
comparing its resulting trace with the partial trace from unit tests
may yield wrong results. $\blacksquare$
%Why cannot use unit test to achieve the trace? since it is incomplete


%why cannot delta debugging? no working state, no predicate

\vspace{1mm}
\noindent \textbf{Why not only store failing traces in the database?}
It is more developers to provide correct executions, instead of
anticipating the possibly error behaviors a user may encounter. $\blacksquare$
A broader question is which kind of informatin should be recorded
from program execution. \ourtool uses predicate as the abstraction level,
and emprically compares with two other abstractions (a coarser abstraction
at the method level, and a finer abstract at the statement level). Investigating
other abstraction levles remains as our future work.

\vspace{1mm}
\noindent \textbf{What if a similar correct trace is not available?}
This indicate the inadequacy of testing. We show this in experiments, if a
similar trace is not available,... combine with existing
traces creation techniques, cite Xiangyu's work on selecting peer

%Why dynamic slicing is not usable? No seed statement, and great overhead. Using JSlicer incurs
%a great overhead. It needs to track every instruction and
%perform synchronization when dependence graph is updated.

%Our technique can be seen as a way to reduce overhead,
%including selective profiling, and static pre-processing
%techniques.

