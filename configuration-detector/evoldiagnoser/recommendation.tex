%An alternate path is any path not taken by the actual
%program execution that starts at a conditional
%branch instruction for which the branch condition
%is affected by one or more configuration options.

\input{diagalgorithm.tex}

In this step, \ourtool links the control flow differences
to one or more root cause configuration options.
The key idea is to identify configuration options that
may affect the behaviorally-deviated predicates, and then rank
these options by the degree of how they may cause
the differences.

%\subsubsection{Attributing Trace Differences to Configuration Options}

To identify the configuration options that can affect
a predicate, a straightforward way is to use program slicing~\cite{}
to compute a forward slice from the initialization statement
of a configuration option, and then check whether the predicate is
in the slice. Unfortunately, traditional
full slicing~\cite{} is infeasible due
to its conservatism, such as the need of handling pointers
and the need of following both data and control dependences.
%As been experimentally demonstrated in our
%previous work~\cite{}, traditional full slicing includes
%too much of the program, and can significantly affect an analysis's
%accuracy. 
\todo{an example}


To address this limitation, \ourtool uses thin slicing~\cite{}
to identify configuration options that \textit{directly} affect
a predicate. Different from traditional full slicing~\cite{},
thin slicing \textit{only} follows the data flow dependencies
from the seed (i.e., the initialization statement of a
configuration option), and ignores control flow dependencies
as well as uses of base pointers. This property separates
pointer computations from the flow of configuration option
values and naturally connects a configuration option with its
directly affected statements. \todo{an example}. Section~\ref{sec:alternative}
empirically demonstrates that traditional full slicing includes
too much of the program, and can significantly affect an analysis's
accuracy; while thin slicing is a better
choice.


To distinguish the likelihood of each configuration
option being the root cause, \ourtool associates each
configuration option with a weight, which represents the strength of
the causual relationship between the configuration option
and the execution differences.
A larger weight value indicates that a configuration option
can potentially affect more statements wihthin the control
flow differences as its value propagates in the program, and thus
the configuration option is more likely
to be the root cause.
%which is the number
%of affected statements, as its effects propagates
%in the program.  The weight. 
%If a configuration option
%potentially affects more statements that are decided
%by a behaviorally-different predicate, it is more likely
%to be the root cause.

\todo{explain with the pseduo code}
Figure~\ref{fig:recommend} sketches the configuration option
recommendation algorithm.
For each predicate with different behaviors between two
versions, \ourtool first attributes the control flow difference 
to its affecting configuration options. Then,
\ourtool calculates a cost for each predicate by computing
the number of statements whose execution are determined
by the predicate's evaluation result. Specifically,
\ourtool statically exams the source code to compute
the immediate post-dominant statement of a predicate, and then
analyzes the execution trace to count the number of statements that
are executed between the predicate and its post-dominant
statement. After that, the algorithm multiples the predicate's deviation
degree (computed by \todo{xx}) by the number of executed statements,
and updates the weight of all affecting options.
%attributes the divergence to the affecting options.

\ourtool outputs a ranked list of
configuration options that might be responsible for the
behavior differences. In the output list, if an option only appears
in the old program version, it indicates that option may not
take any effect in the new version (e.g., the option has
been renamed), and the user should switch to a different option.
If an option only appears in the new version or in both
versions, it indicates that the user should change its
existing value.
\todo{rephrase the above to avoid confusion.}

%Finally, the algorithm sums
%first summing
%the total number of instructions executed via this
%predicate. It attributes the divergence
%to root cause configuration options by multiplying
%the cost of the divergence by the weights of the configuration
%options that are relevant to the divergence.


%\ourtool statically analyzes
%the effects of each configuration option when it is
%assigned to a different value.
%Specifically, \ourtool propagates the effect of
%a configuration option to other program statements
%based on control flow dependencies in the program. 



%Two configuration options are considered equal
%root causes even if one has a direct causal
%relationship to a location (e.g., the value
%in memory was read directly from the configuration value)
%and another has a nebulous relationship (e.g., 
%its effects is propagated along a long chain
%of conditional assignments).

%Data flow dependencies are treated to be more likely
%to lead to the root cause than control flow
%dependencies. Control flow dependencies are assumed
%to be more likely to the root cause if they occur
%later in the execution (i.e., closer to the
%deviated execution paths).

%Assign control flow dependence only half the weight
%of the weight introduced by data flow dependencies.
%Further, each nested conditional branches reduces
%the weight by prior branch in the nest one half.

%what about 
%if(a) \{
%
%    if(b) \{
%        //should a and b equally important
%     \}
%    \}



%\todo{mention implementation details about recursive, avoid double count}


%\ourtool also tracks implicit control flow dependencies.

%A predicate's execution depends on the value of
%the configuration option, and the associated weight
%indicates the strength of the dependency.

%\ourtool assumes that control flow dependencies are more likely
%to lead to the root cause if they
%occur closer to the predicate being executed.

%This represents the belief that the execution of
%the basic block is affected by XXX.
%Since these are two independent probabilities:
%potentially changing either of the two options
%might cause the basic block to not have been executed.
%Thus, the weights of configuration options associated
%with a basic block need not sum to one.

%\ourtool determines the root cause of each behaviorally-different
%predicate.  



%Essentially, this step answers the question:
%``how likely is a configuration
%option cause the execution differences?''.

%\ourtool uses two heuristics: xxx.
%These heuristics cause real root causes to rank
%higher than false positives.


%\ourtool next determines why each different path
%gets executed. \ourtool associates each block
%with a set of root causes, More specifically,
%it uses thin slicing to identify a
%set of configuration options for each deviated
%execution path as the root causes.
