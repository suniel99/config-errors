% -*- LaTeX -*-

%An alternate path is any path not taken by the actual
%program execution that starts at a conditional
%branch instruction for which the branch condition
%is affected by one or more configuration options.

\input{diagalgorithm.tex}

In this step, \ourtool attributes the control flow differences
to one or more root cause configuration options.
The key idea is to identify configuration options that
may affect the behaviorally-deviated predicates, and then rank
these options by the deviation value (computed by the
{deviation} method in Figure~\ref{fig:recommend})
and the number of executed statements they control (computed
by the {getExecutedStmtNum} auxiliary method in Figure~\ref{fig:recommend}).

%\subsubsection{Attributing Trace Differences to Configuration Options}

To identify the configuration options that can affect
a predicate, a straightforward way is to use program slicing~\cite{Weiser:1981}
to compute a forward slice from the initialization statement
of a configuration option, and then check whether the predicate is
in the slice. Unfortunately, traditional
full slicing~\cite{Weiser:1981} is infeasible due
to its conservatism, such as the need of handling pointers
and the need of following both data and control dependences.
%As been experimentally demonstrated in our
%previous work~\cite{}, traditional full slicing includes
%too much of the program, and can significantly affect an analysis's
%accuracy. 


To address this limitation, \ourtool uses thin slicing~\cite{Sridharan:2007}
to identify configuration options that \textit{directly} affect
a predicate. Different from traditional full slicing,
thin slicing \textit{only} follows the data flow dependencies
from the seed (i.e., the initialization statement of a
configuration option), and ignores control flow dependencies
as well as uses of base pointers. This property separates
pointer computations from the flow of configuration option
values and naturally connects a configuration option with its
directly affected statements. Section~\ref{sec:alternative}
empirically demonstrates that traditional full slicing includes
too much of the program, and can significantly affect an analysis's
accuracy; while thin slicing is a better
choice.


To distinguish the likelihood of each configuration
option being the root cause, \ourtool associates each
configuration option with a weight, which represents the strength of
the causal relationship between the configuration option
and the execution differences.
A larger weight value indicates that a configuration option
can potentially attributes more to the control
flow differences as its value propagates in the program, and thus
the configuration option is more likely to be the root cause.
%which is the number
%of affected statements, as its effects propagates
%in the program.  The weight. 
%If a configuration option
%potentially affects more statements that are decided
%by a behaviorally-different predicate, it is more likely
%to be the root cause.

Figure~\ref{fig:recommend} sketches the configuration option
recommendation algorithm.
For each predicate in both versions,
\ourtool first attributes the control flow difference 
to its affecting configuration options (lines 4 and 12). Then,
\ourtool computes the number of executed statements controlled
by that predicate (lines 5 and 13). To obtain the number of
executed statements controlled by a predicate,
the getExecutedStmtNum method first statically examines the
source code to compute the immediate post-dominant statement
of a predicate, and then traverses the execution trace to count
the number of statements that
are executed between the predicate and its post-dominant
statement. 
\ourtool mulitples the a predicate's cross-version deviation value 
with the number of executed statements, and updates the
weight of each affecting configuration option (lines 5--8
and 13--16).
%\ourtool first iterates each predicate pair with different
%behaviors between two versions (line 2), and then attribute
%the behavior difference to its affecting configuration options (lines 4--17).
%For each predicate pair, \ourtool analyzes the predicate
%in the old and new program versions separately in lines 4--10
%and lines 11--17, respectively. For a predicate, \ourtool
%first identifies all configuration options that can affect its
%behavior (lines 5 and 12). The weight of each configuration option
%is accumulated by summing up the result of multiplying the
%deviation value of its affected predicate with the number of
%executed statements determined by that predicate (lines 6 and 13).
Finally, \ourtool ranks all affecting configuration options
in decreasing order, and outputs a ranked list of suspicious
options that might be responsible for the
behavior differences (line 18). 

In \ourtool, if two configuration options have the
same weights, \ourtool prefers the configuration option
having more statements in its thin slice. This heuristic
is based on the intuition that configuration options affecting
more statements seem more likely to be relevant to the behavior
differences.

%In the output list, if an option affects 
%a predicates in the old program version,
%it indicates that option may have a different effect on the new
%version (e.g., the option has
%been renamed), and the user should switch to a different option.
%If an option affects predicates in the new version or in both
%versions, it indicates that the user should change its
%existing value.

%\todo{need more clarification of above.}


%Finally, the algorithm sums
%first summing
%the total number of instructions executed via this
%predicate. It attributes the divergence
%to root cause configuration options by multiplying
%the cost of the divergence by the weights of the configuration
%options that are relevant to the divergence.


%\ourtool statically analyzes
%the effects of each configuration option when it is
%assigned to a different value.
%Specifically, \ourtool propagates the effect of
%a configuration option to other program statements
%based on control flow dependencies in the program. 



%Two configuration options are considered equal
%root causes even if one has a direct causal
%relationship to a location (e.g., the value
%in memory was read directly from the configuration value)
%and another has a nebulous relationship (e.g., 
%its effects is propagated along a long chain
%of conditional assignments).

%Data flow dependencies are treated to be more likely
%to lead to the root cause than control flow
%dependencies. Control flow dependencies are assumed
%to be more likely to the root cause if they occur
%later in the execution (i.e., closer to the
%deviated execution paths).

%Assign control flow dependence only half the weight
%of the weight introduced by data flow dependencies.
%Further, each nested conditional branches reduces
%the weight by prior branch in the nest one half.

%what about 
%if(a) \{
%
%    if(b) \{
%        //should a and b equally important
%     \}
%    \}



%\todo{mention implementation details about recursive, avoid double count}


%\ourtool also tracks implicit control flow dependencies.

%A predicate's execution depends on the value of
%the configuration option, and the associated weight
%indicates the strength of the dependency.

%\ourtool assumes that control flow dependencies are more likely
%to lead to the root cause if they
%occur closer to the predicate being executed.

%This represents the belief that the execution of
%the basic block is affected by XXX.
%Since these are two independent probabilities:
%potentially changing either of the two options
%might cause the basic block to not have been executed.
%Thus, the weights of configuration options associated
%with a basic block need not sum to one.

%\ourtool determines the root cause of each behaviorally-different
%predicate.  



%Essentially, this step answers the question:
%``how likely is a configuration
%option cause the execution differences?''.

%\ourtool uses two heuristics: xxx.
%These heuristics cause real root causes to rank
%higher than false positives.


%\ourtool next determines why each different path
%gets executed. \ourtool associates each block
%with a set of root causes, More specifically,
%it uses thin slicing to identify a
%set of configuration options for each deviated
%execution path as the root causes.

