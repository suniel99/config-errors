\section{Introduction}
\label{sec:introduction}

Many modern software systems are configurable. They
have a large number of configuration options for users
to customize their behavior. This flexibility has a cost:
a small configuration error might lead to hard-to-diagnose
behaviors.
%when something goes wrong, diagnosing a configuration
%error can be both time-consuming and furstrating.

Software configuration errors are errors in which
the application code and the input is correct, but the software is
configured so that it does not behave
as desired by the end-user. Such errors may lead software to crash,
produce erroneous output, or simply perform poorly.
In practice, software configuration
errors are \textit{prevalent}, \textit{severe}, and
\textit{hard to debug}, but they are \textit{actionable} for users to fix.


%In many modern software systems, configuration errors have been
%the dominant cause of problems~\cite{}.
A recent analysis of Yahoo's mission-critical Zookeeper service
showed that software misconfigurations accounted for
the majority of all user-visible failures~\cite{bft}. Another
recent study analyzed reported problems of a commercial
storage company, and found configuration-related issues
caused about 31\% of all user-visible failures~\cite{Yin:2011:ESC}.
Further, as described in a recent article about system deployment experience
in Google, the vast majority of production failures (in Google)
arise not due to bugs in the software, but bugs in the
configuration settings (i.e., configuration errors)
that control the software~\cite{googleconf}.
Not only are configuration errors prevalent, they
can have high, sometimes disastrous impacts. For example,
an outage in Facebook, due to
an incorrect configuration value, left the website 
inaccessible for about 2 hours~\cite{fbout}. 
The entire .se domain of country Sweden was unavailable
for about 1 hour, due to a DNS misconfiguration problem~\cite{sedown}.
Such incidents affected millions of users. Furthermore, configuration
errors are difficult to diagnose. Diagnosing
configuration errors has become a difficult problem; 
techniques helping escape from the ``configuration hell''
are highly demanded~\cite{googleconf}.

However, on the other hand, different than software bugs
which can only be fixed by experienced software developers, fixing a software
configuration error is more \textit{actionable} for software end-users
or system administrators. These users are not the software developers,
and do not have the right expertise to understand (or even access to)
the source code;  but they can fix a configuration error by simply changing
values of certain configuration options.


\subsection{Configuration Evolution}
\label{sec:evolerror}

Continual change is a fact of life for software systems.
Among software changes, configuration changes are prevalent.
In a study of 9 real-world configurable software
systems (Section~\ref{sec:study}),
we found that configuration changes happen in \textit{every} studied
version of \textit{each} system. In many 
cases, directly reusing the existing configuration
for the old version for the new
version can lead the software exhibit \textit{undesired} behaviors,
even the software is working exactly as \textit{intended}.
In practice, such improper reconfiguration can lead to serious results.
For example, on July 26 2012, after software updating,
a small misconfiguration caused a system error, and resulted in
Microsoft's public cloud hosting and development platform, Azure,
being unavailable for about two and a half hours~\cite{msdown}.

%After upgrading to a new version,
%users often need to carefully exam the existing configuration, and may
%configure the software properly. \todo{xx}
%Otherwise, the software is working exactly as intended, but the
%wrong configuration is leading it to exhibit the undesired behavior.
%\todo{not the right place}
%Inappropriate reconfiguration can lead to serious results.

%Configuration errors are different from software regression bugs.
%They can still happen even after an unrealistically comprehensive
%regression test suite (with 100\% coverage ) passes. This is primarily
%because 

Unlike software regression bugs, configuration errors are mostly user driven.
They occur when the use of software is unexpected
situations, in which it does not behave as a user would expect.
For software developers,
it is impossible for them to test software in every possible
situation in which it might be misconfigured; in fact, it is usually
impossible even to foresee every such situation. 


Take the popular JMeter performance testing tool as an example, 
in version 2.8, the testing report is saved as an XML
file after running an example command
%\footnote{\CodeIn{jmeter -n -t ../threadgroup.jmx -l ../output.jtl -j ../test.log}}
from in the user manual.
However, when upgrading to version 2.9, 
after executing the same command, the testing report is saved
in a CSV file. Further, all JMeter regression tests pass 
on the updated version, but the new JMeter version
just behaves as \textit{intended} but \textit{differently}
than a user was expecting.


%To understand why a configuration error happens and
%troubleshoot it to obtain the desired behavior,
%users often need to seek information
%from online help forums, software manuals, or
%ask experts. This process can be tedious, laborious, and frustrating.

Our technique (and its tool implementation \ourtool) can help
diagnose configuration errors. For the JMeter example,
users first demonstrate the different
behaviors on two \ourtool-instrumented
JMeter versions. Then, \ourtool analyzes the
recorded execution traces produced by the two instrumented
versions, and outputs a ranked list of root cause configuration options.
At the top of the list is the
\CodeIn{output\_format} option, whose default value is \CodeIn{CSV}
in version 2.9.
To resolve this problem, users only need to change
its value to \CodeIn{XML}.

\subsection{Configuration Option Recommendation}

Broadly speaking, diagnosing a configuration
error can be divided into three separate tasks:
reproducing the error, recommending which specific
configuration option should be changed for the undesired
behavior, and determining a better value for the
configuration option to fix the error. \ourtool addresses
the second task: recommending the root cause configuration options.
%a configuration error.

\ourtool aims to help two types of users: software end-users
who may have problems with software installed on their
personal computers; and system administrators who are
responsible for maintaining production systems.
They can use \ourtool to diagnose an unexpected configuration
problem during software evolution. 
%to troubleshoot an
%error they encounter but do not know how to fix it. 

%when they counter
%an error that they do not know how to fix, to troubleshoot a
%configuration error 
%\ourtool's output can help such users resolve the problems
%they encounter.

%\ourtool focuses on diagnosing configuration errors
%caused by software evolution. 
The key idea of \ourtool is to approximate program behavioral
differences by control flow differences between 
two execution traces (produced by running the old
and new program versions, respectively),
and then reasons about configuration options
might cause such differences. It uses
three steps, as illustrated in Figure~\ref{fig:overview},  to link the undesired
behavior to specific root cause configuration options:

\vspace{-2mm}

\begin{itemize}

\item \textbf{Instrumentation and Profiling.} \ourtool
instruments both old and new program versions by inserting
code to monitor the execution of each statement as well as the
evaluation result of every predicate. Then, it asks users to
demonstrate the different behaviors on two instrumented
program versions. 
%User demonstration produces two execution
%traces resulting from the desired and undesired program
%behaviors, respectively.

\item \textbf{Execution Trace Comparison.}
\ourtool analyzes two execution traces to identify
the control flow differences. In particular, \ourtool
identify program predicates that are behaving
differently between two versions. These
behaviorally-different predicate 
provide useful evidence for what parts of a program might
be behaving abnormally
and why.

\item \textbf{Configuration Option Recommendation.} 
\ourtool uses a lightweight static dependence analysis
technique, called thin slicing~\cite{}, to attribute
control flow differences to specific configuration options.
It outputs a ranked list of suspcious options to the users.


\end{itemize}

Compared to existing error diagnosis
techniques~\cite{}, \ourtool differs in four
key aspects:

\begin{itemize}
\item \textbf{It diagnoses configuration errors across versions}.
Most existing configuration error diagnosis techniques
exclusively focus on identifying errors in a single program
version~\cite{}. By contrast, \ourtool targets
configuration errors caused by software evolution, and
works on two different versions of the same program. 
It uses the desired behavior on the old software version
as a baseline with which to compare new program behavior against, and only
reasons about the behavioral differences.


\item \textbf{It requires no testing oracle}.
Some existing work~\cite{} require users to answer the difficult
questions like ``why is the software not working'', or
``is the software currently working'' by writing a testing
oracle to check the software behavior. By contrast,
\ourtool eliminates such assumption and only requires users to
demonstrate the different behaviors on two versions.
\ourtool uses the execution trace produced in the old
version as an approximate oracle to
reason about the undesired behavior in the new version.

\item \textbf{It determines likely root cause options}.
Many error diagnosis and debugging techniques primarily focus on
determining \textit{what} causes the undesired behaviors, e.g.,
a snippet of code -- they leave the more challenging
question of \textit{how} to fix the undesired behaviors
unanswered. Users must manually inspect the analysis
report to infer
the root cause, e.g., a configuration option,
of the unexpected behaviors 
based on their expertise and knowledge of the software.
By contrast, \ourtool explicitly guides users to specific
configuration options which may fix the error.

\item \textbf{It requires no OS-level support}. \ourtool
does not need alternations to the JVM, operating systems, or
standard library. This makes \ourtool more portable, and
distinguishes it from related techniques, such as
OS-level configuration error diagnosis~\cite{}.

\end{itemize}

\subsection{Evaluation}

We implemented \ourtool for Java software, and empirically evaluated
its effectiveness using \errornum configuration errors
from \subjnum open-source configurable Java software. 
We used \ourtool to recommend configuration options whose values
can be changed to fix each error.
\ourtool successfully recommend correct configuration options
for XXX errors. In XX errors, the correct option was \ourtool's first
suggestion. In XXX errors, the correct option was among
\ourtool's top 3 suggestions. 
\ourtool fails to recommend correct options for the remaining
one error. \ourtool is fast enough for practical use,
taking less than XX minutes to diagnose one configuration error, on average.
\ourtool's accuracy and speed make it a promising technique.


We compared \ourtool to two existing configuration error diagnosis
techniques, called \prevtool~\cite{} and \conftool~\cite{}.
\prevtool assumes the existence of some correct execution traces
on the new program version, and compares the undesired execution
trace with them to identify the different parts. \conftool exclusively
focuses on diagnosing crashing configuration errors.
By contrast, \ourtool eliminates \prevtool's assumption and
can diagnose both crashing errors and non-crashing errors. Our experiments
show that \ourtool significantly outperforms these two existing techniques.

Finally, we evaluated an internal design choice of \ourtool. We showed
that using thin slicing is better choice than the traditional full
slicing to reason about the root cause configuration options.

%Overall, we find that \ourtool is highly effective at helping
%identify the root cause of cross-version behavioral differences. 

\subsection{Contributions}

This paper makes the following main contributions:

\begin{itemize}
\vspace{-3mm}
\item \textbf{Study.} We describe an empirical
study of 9 configurable software systems.
Our study indicates that software configuration changes
are frequent and persistent during its evolution (Section~\ref{sec:study}).

\item \textbf{Technique.} We present a technique to diagnose
configuration errors for evolving software. Our technique
uses dynamic profiling, execution trace comparison, and
static analysis to link certain undesired behaviors to a
specific responsible configuration option (Section~\ref{sec:technique}).

\item \textbf{Implementation.} We implemented our technique
in a tool, called \ourtool, for Java software (Section~\ref{sec:implementation}).
It is publicly available at \url{http://config-errors.googlecode.com}.

\item \textbf{Evaluation.} We applied \ourtool to \errornum configuration
errors from \subjnum configurable software systems,
and compared it with existing techniques.
The results show the accuracy and efficiency of \ourtool (Section~\ref{sec:evaluation}).
\end{itemize}
